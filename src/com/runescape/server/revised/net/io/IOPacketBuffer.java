/**
 * Eclipse Public License - v 1.0
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
 * OF THE
 * PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * 1. DEFINITIONS
 * 
 * "Contribution" means:
 * 
 * a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and
 * b) in the case of each subsequent Contributor:
 * i) changes to the Program, and
 * ii) additions to the Program;
 * where such changes and/or additions to the Program originate from and are distributed by that particular Contributor. A Contribution
 * 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf.
 * Contributions do not include additions to the Program which: (i) are separate modules of software distributed in conjunction with the Program
 * under their own license agreement, and (ii) are not derivative works of the Program.
 * "Contributor" means any person or entity that distributes the Program.
 * 
 * "Licensed Patents" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone
 * or when combined with the Program.
 * 
 * "Program" means the Contributions distributed in accordance with this Agreement.
 * 
 * "Recipient" means anyone who receives the Program under this Agreement, including all Contributors.
 * 
 * 2. GRANT OF RIGHTS
 * 
 * a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license
 * to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor,
 * if any, and such derivative works, in source code and object code form.
 * b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license
 * under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source
 * code and object code form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the
 * Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The
 * patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.
 * c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided
 * by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor
 * disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise.
 * As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other
 * intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to distribute the
 * Program, it is Recipient's responsibility to acquire that license before distributing the Program.
 * d) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright
 * license set forth in this Agreement.
 * 3. REQUIREMENTS
 * 
 * A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:
 * 
 * a) it complies with the terms and conditions of this Agreement; and
 * b) its license agreement:
 * i) effectively disclaims on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions
 * of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;
 * ii) effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and
 * consequential damages, such as lost profits;
 * iii) states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and
 * iv) states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner
 * on or through a medium customarily used for software exchange.
 * When the Program is made available in source code form:
 * 
 * a) it must be made available under this Agreement; and
 * b) a copy of this Agreement must be included with each copy of the Program.
 * Contributors may not remove or alter any copyright notices contained within the Program.
 * 
 * Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients
 * to identify the originator of the Contribution.
 * 
 * 4. COMMERCIAL DISTRIBUTION
 * 
 * Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this
 * license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering
 * should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in
 * a commercial product offering, such Contributor ("Commercial Contributor") hereby agrees to defend and indemnify every other Contributor
 * ("Indemnified Contributor") against any losses, damages and costs (collectively "Losses") arising from claims, lawsuits and other legal actions
 * brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in
 * connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or
 * Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly
 * notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the
 * Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim
 * at its own expense.
 * 
 * For example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial
 * Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims
 * and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend
 * claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay
 * any damages as a result, the Commercial Contributor must pay those damages.
 * 
 * 5. NO WARRANTY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and
 * assumes all risks associated with its exercise of rights under this Agreement , including but not limited to the risks and costs of program
 * errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.
 * 
 * 6. DISCLAIMER OF LIABILITY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION
 * OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * 
 * 7. GENERAL
 * 
 * If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the
 * remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum
 * extent necessary to make such provision valid and enforceable.
 * 
 * If Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program
 * itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's
 * rights granted under Section 2(b) shall terminate as of the date such litigation is filed.
 * 
 * All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this
 * Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights
 * under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However,
 * Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.
 * 
 * Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may
 * only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this
 * Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the
 * initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate
 * entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be
 * distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is
 * published, Contributor may elect to distribute the Program (including its Contributions) under the new version. Except as expressly stated in
 * Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement,
 * whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved.
 * 
 * This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to
 * this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose. Each party waives its rights
 * to a jury trial in any resulting litigation.
 */
package com.runescape.server.revised.net.io;

import com.runescape.server.ServerConstants;
import com.runescape.server.ServerMain;
import com.runescape.server.revised.logic.encryption.Cryption;
import com.runescape.server.revised.net.packets.codec.login.RevisionType;

public class IOPacketBuffer {

	public Cryption packetEncryption = null;
	public byte[] buffer = null;
	public int currentOffset = 0;
	public int bitPosition = 0;
	private static final int frameStackSize = 10;
	private int frameStackPtr = -1;
	private final int[] frameStack = new int[IOPacketBuffer.frameStackSize];
	public static int[] bitMaskOut = new int[32];

	static {
		for (int i = 0; i < 32; i++) {
			IOPacketBuffer.getBitMaskOut()[i] = (1 << i) - 1;
		}
	}

	public IOPacketBuffer() {}

	public IOPacketBuffer(final byte[] buffer) {
		this.setBuffer(buffer);
		this.setCurrentOffset(0);
	}

	public void readSkip(final int length) {
		this.currentOffset += length;
	}

	public int readUnsignedByteA() {
		return (this.getBuffer()[this.currentOffset++] - 128) & 0xFF;
	}

	public int readUnsignedByteC() {
		return -this.readUnsignedByte();
	}

	public int readUnsignedByteS() {
		return (128 - this.readUnsignedByte());
	}

	public void writeByteA(final int i) {
		this.ensureCapacity(1);
		this.writeByte((byte) (i + 128));
	}

	public void writeByteS(final int i) {
		this.ensureCapacity(1);
		this.writeByte((byte) (128 - i));
	}

	public void writeByteC(final int i) {
		this.ensureCapacity(1);
		this.writeByte((byte) -i);
	}

	public int readSignedWordBigEndian() {
		this.setCurrentOffset(this.currentOffset += 2);
		int i = ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xFF) << 8) + (this.getBuffer()[this.getCurrentOffset() - 2] & 0xFF);
		if (i > 32767) {
			i -= 0x10000;
		}
		return i;
	}

	public int readSignedWordA() {
		this.setCurrentOffset(this.currentOffset += 2);
		int i = ((this.getBuffer()[this.getCurrentOffset() - 2] & 0xFF) << 8) + ((this.getBuffer()[this.getCurrentOffset() - 1] - 128) & 0xFF);
		if (i > 32767) {
			i -= 0x10000;
		}
		return i;
	}

	public int readSignedWordBigEndianA() {
		this.setCurrentOffset(this.currentOffset += 2);
		int i = ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xFF) << 8) + ((this.getBuffer()[this.getCurrentOffset() - 2] - 128) & 0xFF);
		if(i > 32767) {
			i -= 0x10000;
		}
		return i;
	}

	public int readUnsignedWordBigEndian() {
		this.setCurrentOffset(this.currentOffset += 2);
		return ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xFF) << 8) + (this.getBuffer()[this.getCurrentOffset() - 2] & 0xFF);
	}

	public int readUnsignedWordA() {
		this.setCurrentOffset(this.currentOffset += 2);
		return ((this.getBuffer()[this.getCurrentOffset() - 2] & 0xFF) << 8) + ((this.getBuffer()[this.getCurrentOffset() - 1] - 128) & 0xFF);
	}

	public int readUnsignedWordBigEndianA() {
		this.setCurrentOffset(this.currentOffset += 2);
		return ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xFF) << 8) + ((this.getBuffer()[this.getCurrentOffset() - 2] - 128) & 0xFF);
	}

	public void writeWordBigEndianA(final int i) {
		this.ensureCapacity(2);
		this.writeByte((byte) (i + 128));
		this.writeByte((byte) (i >> 8));
	}

	public void writeWordA(final int i) {
		this.ensureCapacity(2);
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) (i + 128));
	}

	public void writeWordBigEndian_dup(final int i) {
		this.ensureCapacity(2);
		this.writeByte((byte) i);
		this.writeByte((byte) (i >> 8));
	}

	public int readDWord_v1() {
		this.setCurrentOffset(this.currentOffset += 4);
		return ((this.getBuffer()[this.getCurrentOffset() - 2] & 0xff) << 24) + ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xff) << 16) + ((this.getBuffer()[this.getCurrentOffset() - 4] & 0xff) << 8) + (this.getBuffer()[this.getCurrentOffset() - 3] & 0xFF);
	}

	public int readDWord_v2() {
		this.setCurrentOffset(this.currentOffset += 4);
		return ((this.getBuffer()[this.getCurrentOffset() - 3] & 0xFF) << 24) + ((this.getBuffer()[this.getCurrentOffset() - 4] & 0xFF) << 16) + ((this.getBuffer()[this.getCurrentOffset() - 1] & 0xFF) << 8) + (this.getBuffer()[this.getCurrentOffset() - 2] & 0xFF);
	}

	public void writeDWord_v1(final int i) {
		this.ensureCapacity(4);
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) i);
		this.writeByte((byte) (i >> 24));
		this.writeByte((byte) (i >> 16));
	}

	public void writeDWord_v2(final int i) {
		this.ensureCapacity(4);
		this.writeByte((byte) (i >> 16));
		this.writeByte((byte) (i >> 24));
		this.writeByte((byte) i);
		this.writeByte((byte) (i >> 8));
	}

	public void readBytes_reverse(final byte abyte0[], final int i, final int j) {
		for(int k = (j + i) - 1; k >= j; k--) {
			abyte0[k] = this.getBuffer()[this.currentOffset++];
		}
	}

	public void writeBytes_reverse(final byte[] abyte0, final int i, final int j) {
		this.ensureCapacity(i);
		for (int k = (j + i) - 1; k >= j; k--) {
			this.getBuffer()[this.currentOffset++] = abyte0[k];
		}
	}

	public void readBytes_reverseA(final byte[] abyte0, final int i, final int j) {
		this.ensureCapacity(i);
		for (int k = (j + i) - 1; k >= j; k--) {
			abyte0[k] = (byte) (this.getBuffer()[this.currentOffset++] - 128);
		}
	}

	public void writeBytes_reverseA(final byte abyte0[], final int i, final int j) {
		this.ensureCapacity(i);
		for (int k = (j + i) - 1; k >= j; k--) {
			this.getBuffer()[this.currentOffset++] = (byte) (abyte0[k] + 128);
		}
	}

	public void createFrame(final int id) {
		this.ensureCapacity(1);
		this.writeByte((byte) (id + this.getPacketEncryption().getNextKey()));
	}

	public void createFrameVarSize(final int id) {
		this.ensureCapacity(3);
		this.writeByte ((byte) (id + this.getPacketEncryption().getNextKey()));
		this.writeByte((byte) 0);
		if (this.frameStackPtr >= (IOPacketBuffer.frameStackSize-1)) {
			throw new RuntimeException("Stack overflow");
		} else {
			this.frameStack[++this.frameStackPtr] = this.currentOffset;
		}
	}

	public void createFrameVarSizeWord(final int id)	 {
		this.ensureCapacity(2);
		this.writeByte((byte) (id + this.packetEncryption.getNextKey()));
		this.writeWord(0);
		if(this.frameStackPtr >= (IOPacketBuffer.frameStackSize-1)) {
			throw new RuntimeException("Stack overflow");
		} else {
			this.frameStack[++this.frameStackPtr] = this.currentOffset;
		}
	}

	public void endFrameVarSize() {
		if(this.frameStackPtr < 0) {
			throw new RuntimeException("Stack empty");
		} else {
			this.writeFrameSize(this.currentOffset - this.frameStack[this.frameStackPtr--]);
		}
	}

	public void endFrameVarSizeWord() {
		if(this.frameStackPtr < 0) {
			throw new RuntimeException("Stack empty");
		} else {
			this.writeFrameSizeWord(this.currentOffset - this.frameStack[this.frameStackPtr--]);
		}
	}

	public void writeByte(final byte i) {
		this.ensureCapacity(1);
		this.buffer[this.currentOffset++] = i;
	}

	public void writeWord(final int i) {
		this.ensureCapacity(2);
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) i);
	}

	public void writeWordBigEndian(final int i) {
		this.ensureCapacity(2);
		this.writeByte((byte) i);
		this.writeByte((byte) (i >> 8));
	}

	public void write3Byte(final int i) {
		this.ensureCapacity(3);
		this.writeByte((byte) (i >> 16));
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) i);
	}

	public void writeDWord(final int i) {
		this.ensureCapacity(4);
		this.writeByte((byte) (i >> 24));
		this.writeByte((byte) (i >> 16));
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) i);
	}

	public void writeDWordBigEndian(final int i) {
		this.ensureCapacity(4);
		this.writeByte((byte) i);
		this.writeByte((byte) (i >> 8));
		this.writeByte((byte) (i >> 16));
		this.writeByte((byte) (i >> 24));
	}

	public void writeQWord(final long l) {
		this.ensureCapacity(8);
		this.writeByte((byte) (l >> 56));
		this.writeByte((byte) (l >> 48));
		this.writeByte((byte) (l >> 40));
		this.writeByte((byte) (l >> 32));
		this.writeByte((byte) (l >> 24));
		this.writeByte((byte) (l >> 16));
		this.writeByte((byte) (l >> 8));
		this.writeByte((byte) l);
	}

	public void writeString(final java.lang.String s) {
		this.ensureCapacity(s.length());
		System.arraycopy(s.getBytes(), 0, this.buffer, this.currentOffset, s.length());
		this.currentOffset += s.length();
		this.writeByte((byte) 10);
	}

	public void writeBytes(final byte abyte0[], final int i, final int j) {
		this.ensureCapacity(i);
		for(int k = j; k < (j + i); k++) {
			this.writeByte(abyte0[k]);
		}
	}

	public void writeFrameSize(final int i) {
		this.buffer[this.currentOffset - i - 1] = (byte) i;
	}

	public void writeFrameSizeWord(final int i) {
		this.buffer[this.currentOffset - i - 2] = (byte) (i >> 8);
		this.buffer[this.currentOffset - i - 1] = (byte) i;
	}

	public int readUnsignedByte() {
		return this.buffer[this.currentOffset++] & 0xff;
	}

	public byte readSignedByte() {
		return this.buffer[this.currentOffset++];
	}

	public int readUnsignedWord() {
		this.currentOffset += 2;
		return ((this.buffer[this.currentOffset - 2] & 0xff) << 8) + (this.buffer[this.currentOffset - 1] & 0xff);
	}

	public int readSignedWord() {
		this.currentOffset += 2;
		int i = ((this.buffer[this.currentOffset - 2] & 0xff) << 8) + (this.buffer[this.currentOffset - 1] & 0xff);
		if (i > 32767) {
			i -= 0x10000;
		}
		return i;
	}

	public int readDWord() {
		this.currentOffset += 4;
		return ((this.buffer[this.currentOffset - 4] & 0xff) << 24) + ((this.buffer[this.currentOffset - 3] & 0xff) << 16) + ((this.buffer[this.currentOffset - 2] & 0xff) << 8) + (this.buffer[this.currentOffset - 1] & 0xff);
	}

	public long readQWord() {
		final long l = this.readDWord() & 0xffffffffL;
		final long l1 = this.readDWord() & 0xffffffffL;
		return (l << 32) + l1;
	}

	public String readString() {
		final int i = this.getCurrentOffset();
		if (ServerMain.getMain().getRevisionType() == RevisionType.THREE_ONE_SEVEN) {
			while (this.getBuffer()[this.currentOffset++] != 10) {
				;
			}
		} else if (ServerMain.getMain().getRevisionType() == RevisionType.FIVE_SIXTY_TWO) {
			while (this.getBuffer()[this.currentOffset++] != 0) {
				;
			}
		}
		return new String(this.getBuffer(), i, this.getCurrentOffset() - i - 1);
	}

	public void readBytes(final byte abyte0[], final int i, final int j) {
		for (int k = j; k < (j + i); k++) {
			abyte0[k] = this.buffer[this.currentOffset++];
		}
	}

	public void initBitAccess() {
		this.bitPosition = this.currentOffset * 8;
	}

	public void writeBits(int numBits, final int value) {
		this.ensureCapacity(((int) Math.ceil(numBits * 8)) * 4);
		int bytePos = this.getBitPosition() >> 3;
		int bitOffset = 8 - (this.getBitPosition() & 7);
		this.setBitPosition(this.bitPosition += numBits);

		for (; numBits > bitOffset; bitOffset = 8) {
			this.getBuffer()[bytePos] &= ~ IOPacketBuffer.bitMaskOut[bitOffset];
			this.getBuffer()[bytePos++] |= (value >> (numBits-bitOffset)) & IOPacketBuffer.bitMaskOut[bitOffset];

			numBits -= bitOffset;
		}
		if (numBits == bitOffset) {
			this.getBuffer()[bytePos] &= ~ IOPacketBuffer.bitMaskOut[bitOffset];
			this.getBuffer()[bytePos] |= value & IOPacketBuffer.bitMaskOut[bitOffset];
		} else {
			this.getBuffer()[bytePos] &= ~ (IOPacketBuffer.bitMaskOut[numBits]<<(bitOffset - numBits));
			this.getBuffer()[bytePos] |= (value&IOPacketBuffer.bitMaskOut[numBits]) << (bitOffset - numBits);
		}
	}

	public void finishBitAccess() {
		this.setCurrentOffset((this.getBitPosition() + 7) / 8);
	}

	public void ensureCapacity(final int len) {
		if ((this.getCurrentOffset() + len + 1) >= this.getBuffer().length) {
			final byte[] oldBuffer = this.getBuffer();
			final int newLength = (this.getBuffer().length * 2);
			this.setBuffer(new byte[newLength]);
			System.arraycopy(oldBuffer, 0, this.getBuffer(), 0, oldBuffer.length);
			this.ensureCapacity(len);
		}
	}

	public void reset() {
		if (!(this.getCurrentOffset() > ServerConstants.BUFFER_SIZE)) {
			final byte[] oldBuffer = this.getBuffer();
			this.setBuffer(new byte[ServerConstants.BUFFER_SIZE]);
			for (int i = 0; i < this.getCurrentOffset(); i++) {
				this.getBuffer()[i] = oldBuffer[i];
			}
		}
	}

	public void setPacketEncryption(final Cryption packetEncryption) {
		this.packetEncryption = packetEncryption;
	}

	public Cryption getPacketEncryption() {
		return this.packetEncryption;
	}

	public void setBuffer(final byte[] buffer) {
		this.buffer = buffer;
	}

	public byte[] getBuffer() {
		return this.buffer;
	}

	public void setCurrentOffset(final int currentOffset) {
		this.currentOffset = currentOffset;
	}

	public int getCurrentOffset() {
		return this.currentOffset;
	}

	public void setBitPosition(final int bitPosition) {
		this.bitPosition = bitPosition;
	}

	public int getBitPosition() {
		return this.bitPosition;
	}

	public static void setBitMaskOut(final int[] bitMaskOut) {
		IOPacketBuffer.bitMaskOut = bitMaskOut;
	}

	public static int[] getBitMaskOut() {
		return IOPacketBuffer.bitMaskOut;
	}
}