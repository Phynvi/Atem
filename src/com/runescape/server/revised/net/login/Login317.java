/**
 * Eclipse Public License - v 1.0
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
 * OF THE
 * PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * 1. DEFINITIONS
 * 
 * "Contribution" means:
 * 
 * a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and
 * b) in the case of each subsequent Contributor:
 * i) changes to the Program, and
 * ii) additions to the Program;
 * where such changes and/or additions to the Program originate from and are distributed by that particular Contributor. A Contribution
 * 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf.
 * Contributions do not include additions to the Program which: (i) are separate modules of software distributed in conjunction with the Program
 * under their own license agreement, and (ii) are not derivative works of the Program.
 * "Contributor" means any person or entity that distributes the Program.
 * 
 * "Licensed Patents" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone
 * or when combined with the Program.
 * 
 * "Program" means the Contributions distributed in accordance with this Agreement.
 * 
 * "Recipient" means anyone who receives the Program under this Agreement, including all Contributors.
 * 
 * 2. GRANT OF RIGHTS
 * 
 * a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license
 * to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor,
 * if any, and such derivative works, in source code and object code form.
 * b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license
 * under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source
 * code and object code form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the
 * Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The
 * patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.
 * c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided
 * by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor
 * disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise.
 * As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other
 * intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to distribute the
 * Program, it is Recipient's responsibility to acquire that license before distributing the Program.
 * d) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright
 * license set forth in this Agreement.
 * 3. REQUIREMENTS
 * 
 * A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:
 * 
 * a) it complies with the terms and conditions of this Agreement; and
 * b) its license agreement:
 * i) effectively disclaims on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions
 * of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;
 * ii) effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and
 * consequential damages, such as lost profits;
 * iii) states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and
 * iv) states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner
 * on or through a medium customarily used for software exchange.
 * When the Program is made available in source code form:
 * 
 * a) it must be made available under this Agreement; and
 * b) a copy of this Agreement must be included with each copy of the Program.
 * Contributors may not remove or alter any copyright notices contained within the Program.
 * 
 * Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients
 * to identify the originator of the Contribution.
 * 
 * 4. COMMERCIAL DISTRIBUTION
 * 
 * Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this
 * license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering
 * should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in
 * a commercial product offering, such Contributor ("Commercial Contributor") hereby agrees to defend and indemnify every other Contributor
 * ("Indemnified Contributor") against any losses, damages and costs (collectively "Losses") arising from claims, lawsuits and other legal actions
 * brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in
 * connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or
 * Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly
 * notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the
 * Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim
 * at its own expense.
 * 
 * For example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial
 * Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims
 * and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend
 * claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay
 * any damages as a result, the Commercial Contributor must pay those damages.
 * 
 * 5. NO WARRANTY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and
 * assumes all risks associated with its exercise of rights under this Agreement , including but not limited to the risks and costs of program
 * errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.
 * 
 * 6. DISCLAIMER OF LIABILITY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION
 * OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * 
 * 7. GENERAL
 * 
 * If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the
 * remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum
 * extent necessary to make such provision valid and enforceable.
 * 
 * If Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program
 * itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's
 * rights granted under Section 2(b) shall terminate as of the date such litigation is filed.
 * 
 * All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this
 * Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights
 * under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However,
 * Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.
 * 
 * Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may
 * only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this
 * Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the
 * initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate
 * entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be
 * distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is
 * published, Contributor may elect to distribute the Program (including its Contributions) under the new version. Except as expressly stated in
 * Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement,
 * whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved.
 * 
 * This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to
 * this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose. Each party waives its rights
 * to a jury trial in any resulting litigation.
 */
package com.runescape.server.revised.net.login;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.channels.AsynchronousSocketChannel;
import java.nio.channels.Channels;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import com.runescape.server.revised.actor.entity.AbstractEntity;
import com.runescape.server.revised.actor.entity.EntityState;
import com.runescape.server.revised.actor.entity.character.player.login.game.GamePlayer;
import com.runescape.server.revised.actor.entity.character.update.impl.EntityUpdateSystem;
import com.runescape.server.revised.actor.entity.character.update.impl.MinorActionType;
import com.runescape.server.revised.engine.impl.GameEngine;
import com.runescape.server.revised.logic.cycle.CycleConstants;
import com.runescape.server.revised.logic.encryption.Cryption;
import com.runescape.server.revised.net.io.IOPacketBuffer;

public class Login317 {

	private IOPacketBuffer outStream, inStream;
	private InputStream inputStream;
	private OutputStream outputStream;
	private Cryption inStreamDecryption, outStreamDecryption;
	private boolean isClientConnected = false;
	private AbstractEntity<EntityState> player;

	public Login317(final IOPacketBuffer outStream, final IOPacketBuffer inStream, final AsynchronousSocketChannel clientSocket) {
		this.setOutStream(outStream);
		this.setInStream(inStream);
		this.setInputStream(Channels.newInputStream(clientSocket));
		this.setOutputStream(Channels.newOutputStream(clientSocket));
		long clientSessionKey = 0, serverSessionKey = ((long) (Math.random() * 99999999D) << 32) + (long) (Math.random() * 99999999D);
		@SuppressWarnings("unused")
		final byte opcodeRequest = (byte) this.getInStream().readUnsignedByte();
		@SuppressWarnings("unused")
		final int nameHash = this.getInStream().readUnsignedByte();
		this.getInStream().readUnsignedByte();
		for (int i = 0; i < 9; i++) {
			try {
				this.getOutputStream().write(0);
			} catch (final IOException ioe) {
				ioe.printStackTrace();
			}
		}
		this.getOutStream().writeQWord(serverSessionKey);
		this.flushOutStream();
		this.fillInStream(2);
		final int loginType = this.getInStream().readUnsignedByte();
		if ((loginType != 16) && (loginType != 18)) {
			return;
		}
		int loginPacketSize = 0;
		int loginEncryptPacketSize = 0;
		loginPacketSize = this.getInStream().readUnsignedByte();
		loginEncryptPacketSize = loginPacketSize - 40;
		this.fillInStream(loginPacketSize);
		if (this.getInStream().readUnsignedByte() != 255) {
			return;
		}
		this.getInStream().readUnsignedWord();
		@SuppressWarnings("unused")
		final int memory = this.getInStream().readUnsignedByte();
		for (int i = 0; i < 9; i++) {
			Integer.toHexString(this.getInStream().readDWord());
		}
		loginEncryptPacketSize--;
		int tmp = this.getInStream().readUnsignedByte();
		if (loginEncryptPacketSize != tmp) {
			return;
		}
		tmp = this.getInStream().readUnsignedByte();
		if (tmp != 10) {
			return;
		}
		clientSessionKey = this.getInStream().readQWord();
		serverSessionKey = this.getInStream().readQWord();
		@SuppressWarnings("unused")
		final int userID = this.getInStream().readDWord();
		final String name = this.getInStream().readString();
		System.out.println("Name: " + name);
		final String password = this.getInStream().readString();
		System.out.println("Password: " + password);
		final int[] sessionKey = new int[4];
		sessionKey[0] = (int) (clientSessionKey >> 32);
		sessionKey[1] = (int) clientSessionKey;
		sessionKey[2] = (int) (serverSessionKey >> 32);
		sessionKey[3] = (int) serverSessionKey;
		for (int i = 0; i < 4; i++) {
			Integer.toHexString(sessionKey[i]);
		}
		this.setInStreamDecryption(new Cryption(sessionKey));
		for (byte i = 0; i < 4; i++) {
			sessionKey[i] += 50;
		}
		for (byte i = 0; i < 4; i++) {
			Integer.toHexString(sessionKey[i]);
		}
		this.setOutStreamDecryption(new Cryption(sessionKey));
		this.getOutStream().setPacketEncryption(this.getOutStreamDecryption());
		this.setPlayer(new GamePlayer(name, null));
		try {
			this.getOutputStream().write(2); // return code
			if ((name == "Rodriges") || (name == "Josh")) {
				this.getOutputStream().write(2); // rights
			} else {
				this.getOutputStream().write(0); // rights
			}
			this.getOutStream().writeByte((byte) 0);
		} catch (final IOException ioe) {
			ioe.printStackTrace();
		}

		// assert revision == 317;
		// assert name == "Rodrigues";
		// assert password == "jobblebradley123";

		this.getOutStream().createFrame(249);
		this.getOutStream().writeByteA(1);
		this.getOutStream().writeWordA(1);
		this.getOutStream().createFrame(107);
		this.getOutStream().createFrameVarSize(253);
		this.getOutStream().writeString("Welcome to RS3 Newstart!");
		this.getOutStream().endFrameVarSize();
		this.flushOutStream();
		for (byte b = 0; b < 25; b++) {
			this.setSkillLevel(b, (byte) 0, (byte) 0);
		}
		this.setChatOptions((byte) 0, (byte) 0, (byte) 0); // reset private messaging options
		final short[] tabInterfaces = {
				2423, 3917, 638, 3213, 1644, 5608, 1151, 1, 5065, 5715, // modern
				2449, 4445, 147, 6299
		};
		for (byte b = 0; b < 14; b++) {
			this.setTabInterface(b, tabInterfaces[b]);
		}
		this.showMenuOption(4, 0, "Trade With");
		this.showMenuOption(5, 0, "Follow");
		this.showMenuOption(6, 0, "Ban");
		this.showMenuOption(7, 0, "Kick");
		this.showMenuOption(8, 0, "Mute");
		this.sendMapRegion();
		this.sendPlayerUpdating();
		this.setClientConnected(true);
		// new TaskSystem(player, this.getOutStream(), this.getOutputStream());
		@SuppressWarnings("unused")
		final GameEngine gameEngine = new GameEngine(this.getPlayer());
		// gameEngine.getPlayerList().add((GamePlayer) this.player);
		final ScheduledExecutorService entityScheduledExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
		entityScheduledExecutorService.scheduleAtFixedRate(new EntityUpdateSystem(), 0, (((this.getPlayer().getMinorAction() == MinorActionType.WALKING) || (this.getPlayer().getMinorAction() == MinorActionType.CHATTING) || (this.getPlayer().getMinorAction() == MinorActionType.COMBAT)) ? CycleConstants.INSTANT_CYCLE_TIME : CycleConstants.MAJOR_CYCLE_TIME), TimeUnit.MILLISECONDS);
		// final ScheduledExecutorService minorScheduledExecutorService = Executors.newScheduledThreadPool(Runtime.getRuntime().availableProcessors());
		// minorScheduledExecutorService.scheduleAtFixedRate(new MinorUpdateSystem(), 0, CycleConstants.MINOR_CYCLE_TIME, TimeUnit.MILLISECONDS);
	}

	public void sendMapRegion() {
		if (this.getOutStream() != null) {
			this.getOutStream().createFrame(73);
			this.getOutStream().writeWordA(this.getPlayer().getLocation().getRegionX() + 6);
			this.getOutStream().writeWord(this.getPlayer().getLocation().getRegionY() + 6);
			this.flushOutStream();
		}
	}

	public void sendPlayerUpdating() {

		// GameEngine.getGameEngine().getParallelExecutor().executeSystem(new UpdateSystem());

		this.getOutStream().createFrame(81);
		this.getOutStream().writeWord(0); 		// placeholder for size of this packet.
		final int ofs = this.getOutStream().getCurrentOffset();
		this.getOutStream().initBitAccess();

		// update this player
		this.getOutStream().writeBits(1, 1);		// set to true if updating thisPlayer
		this.getOutStream().writeBits(2, 3);		// updateType - 3=jump to pos
		// the following applies to type 3 only
		this.getOutStream().writeBits(2, 0);		// height level (0-3)
		this.getOutStream().writeBits(1, 1);		// set to true, if discarding walking queue (after teleport e.g.)
		this.getOutStream().writeBits(1, 1);		// set to true, if this player is not in local list yet???
		this.getOutStream().writeBits(7, 0x20);	// y-position
		this.getOutStream().writeBits(7, 0x20);	// x-position

		// update other players...?!
		this.getOutStream().writeBits(8, 0);		// number of players to add

		// add new players???
		this.getOutStream().writeBits(11, 2047);	// magic EOF
		this.getOutStream().finishBitAccess();

		this.getOutStream().writeByte((byte) 0);		// ???? needed that to stop client from crashing

		this.getOutStream().writeFrameSizeWord(this.getOutStream().getCurrentOffset() - ofs);
		this.flushOutStream();
	}

	public void setTabInterface(final byte menuID, final short form) {
		if (this.getOutStream() != null) {
			this.getOutStream().createFrame(71);
			this.getOutStream().writeWord(form);
			this.getOutStream().writeByteA(menuID);
		}
	}

	public void setSkillLevel(final byte skillID, final byte level, final int experience) {
		if (this.getOutStream() != null) {
			this.getOutStream().createFrame(134);
			this.getOutStream().writeByte(skillID);
			this.getOutStream().writeDWord_v1(experience);
			this.getOutStream().writeByte(level);
			this.flushOutStream();
		}
	}

	public void setChatOptions(final byte publicChat, final byte privateChat, final byte tradeBlock) {
		if (this.getOutStream() != null) {
			this.getOutStream().createFrame(206);
			this.getOutStream().writeByte(publicChat);
			this.getOutStream().writeByte(privateChat);
			this.getOutStream().writeByte(tradeBlock);
			this.flushOutStream();
		}
	}

	public void showMenuOption(final int i, final int l, final String text) {
		if (this.getOutStream() != null) {
			this.getOutStream().createFrameVarSize(104);
			this.getOutStream().writeByteC(i);
			this.getOutStream().writeByteA(l);
			this.getOutStream().writeString(text);
			this.getOutStream().endFrameVarSize();
			this.flushOutStream();
		}
	}

	public void flushOutStream() {
		if (this.getOutStream() == null) {
			System.out.println("Outstream is null.");
			return;
		}
		if (this.getOutStream().getCurrentOffset() == 0) {
			System.out.println("Current offset is 0.");
			return;
		}
		try {
			this.getOutputStream().write(this.getOutStream().getBuffer(), 0, this.getOutStream().getCurrentOffset());
		} catch (final IOException ioe) {
			ioe.printStackTrace();
		}
		this.getOutStream().setCurrentOffset(0);
	}

	public void fillInStream(final int forceRead) {
		if (this.getInStream() == null) {
			System.out.println("InStream is null.");
			return;
		}
		this.getInStream().setCurrentOffset(0);
		try {
			this.getInputStream().read(this.getInStream().getBuffer(), 0, forceRead);
		} catch (final IOException ioe) {
			ioe.printStackTrace();
		}
	}

	public void setOutStream(final IOPacketBuffer outStream) {
		this.outStream = outStream;
	}

	public IOPacketBuffer getOutStream() {
		return this.outStream;
	}

	public void setInStream(final IOPacketBuffer inStream) {
		this.inStream = inStream;
	}

	public IOPacketBuffer getInStream() {
		return this.inStream;
	}

	public void setInputStream(final InputStream inputStream) {
		this.inputStream = inputStream;
	}

	public InputStream getInputStream() {
		return this.inputStream;
	}

	public void setOutputStream(final OutputStream outputStream) {
		this.outputStream = outputStream;
	}

	public OutputStream getOutputStream() {
		return this.outputStream;
	}

	public void setInStreamDecryption(final Cryption inStreamDecryption) {
		this.inStreamDecryption = inStreamDecryption;
	}

	public Cryption getInStreamDecryption() {
		return this.inStreamDecryption;
	}

	public void setOutStreamDecryption(final Cryption outStreamDecryption) {
		this.outStreamDecryption = outStreamDecryption;
	}

	public Cryption getOutStreamDecryption() {
		return this.outStreamDecryption;
	}

	public void setClientConnected(final boolean isClientConnected) {
		this.isClientConnected = isClientConnected;
	}

	public boolean isClientConnected() {
		return this.isClientConnected;
	}

	public void setPlayer(final AbstractEntity<EntityState> player) {
		this.player = player;
	}

	public GamePlayer getPlayer() {
		return (GamePlayer) this.player;
	}
}