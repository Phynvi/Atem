/**
 * Eclipse Public License - v 1.0
 *
 * THE ACCOMPANYING PROGRAM IS PROVIDED UNDER THE TERMS OF THIS ECLIPSE PUBLIC LICENSE ("AGREEMENT"). ANY USE, REPRODUCTION OR DISTRIBUTION
 * OF THE
 * PROGRAM CONSTITUTES RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT.
 * 
 * 1. DEFINITIONS
 * 
 * "Contribution" means:
 * 
 * a) in the case of the initial Contributor, the initial code and documentation distributed under this Agreement, and
 * b) in the case of each subsequent Contributor:
 * i) changes to the Program, and
 * ii) additions to the Program;
 * where such changes and/or additions to the Program originate from and are distributed by that particular Contributor. A Contribution
 * 'originates' from a Contributor if it was added to the Program by such Contributor itself or anyone acting on such Contributor's behalf.
 * Contributions do not include additions to the Program which: (i) are separate modules of software distributed in conjunction with the Program
 * under their own license agreement, and (ii) are not derivative works of the Program.
 * "Contributor" means any person or entity that distributes the Program.
 * 
 * "Licensed Patents" mean patent claims licensable by a Contributor which are necessarily infringed by the use or sale of its Contribution alone
 * or when combined with the Program.
 * 
 * "Program" means the Contributions distributed in accordance with this Agreement.
 * 
 * "Recipient" means anyone who receives the Program under this Agreement, including all Contributors.
 * 
 * 2. GRANT OF RIGHTS
 * 
 * a) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free copyright license
 * to reproduce, prepare derivative works of, publicly display, publicly perform, distribute and sublicense the Contribution of such Contributor,
 * if any, and such derivative works, in source code and object code form.
 * b) Subject to the terms of this Agreement, each Contributor hereby grants Recipient a non-exclusive, worldwide, royalty-free patent license
 * under Licensed Patents to make, use, sell, offer to sell, import and otherwise transfer the Contribution of such Contributor, if any, in source
 * code and object code form. This patent license shall apply to the combination of the Contribution and the Program if, at the time the
 * Contribution is added by the Contributor, such addition of the Contribution causes such combination to be covered by the Licensed Patents. The
 * patent license shall not apply to any other combinations which include the Contribution. No hardware per se is licensed hereunder.
 * c) Recipient understands that although each Contributor grants the licenses to its Contributions set forth herein, no assurances are provided
 * by any Contributor that the Program does not infringe the patent or other intellectual property rights of any other entity. Each Contributor
 * disclaims any liability to Recipient for claims brought by any other entity based on infringement of intellectual property rights or otherwise.
 * As a condition to exercising the rights and licenses granted hereunder, each Recipient hereby assumes sole responsibility to secure any other
 * intellectual property rights needed, if any. For example, if a third party patent license is required to allow Recipient to distribute the
 * Program, it is Recipient's responsibility to acquire that license before distributing the Program.
 * d) Each Contributor represents that to its knowledge it has sufficient copyright rights in its Contribution, if any, to grant the copyright
 * license set forth in this Agreement.
 * 3. REQUIREMENTS
 * 
 * A Contributor may choose to distribute the Program in object code form under its own license agreement, provided that:
 * 
 * a) it complies with the terms and conditions of this Agreement; and
 * b) its license agreement:
 * i) effectively disclaims on behalf of all Contributors all warranties and conditions, express and implied, including warranties or conditions
 * of title and non-infringement, and implied warranties or conditions of merchantability and fitness for a particular purpose;
 * ii) effectively excludes on behalf of all Contributors all liability for damages, including direct, indirect, special, incidental and
 * consequential damages, such as lost profits;
 * iii) states that any provisions which differ from this Agreement are offered by that Contributor alone and not by any other party; and
 * iv) states that source code for the Program is available from such Contributor, and informs licensees how to obtain it in a reasonable manner
 * on or through a medium customarily used for software exchange.
 * When the Program is made available in source code form:
 * 
 * a) it must be made available under this Agreement; and
 * b) a copy of this Agreement must be included with each copy of the Program.
 * Contributors may not remove or alter any copyright notices contained within the Program.
 * 
 * Each Contributor must identify itself as the originator of its Contribution, if any, in a manner that reasonably allows subsequent Recipients
 * to identify the originator of the Contribution.
 * 
 * 4. COMMERCIAL DISTRIBUTION
 * 
 * Commercial distributors of software may accept certain responsibilities with respect to end users, business partners and the like. While this
 * license is intended to facilitate the commercial use of the Program, the Contributor who includes the Program in a commercial product offering
 * should do so in a manner which does not create potential liability for other Contributors. Therefore, if a Contributor includes the Program in
 * a commercial product offering, such Contributor ("Commercial Contributor") hereby agrees to defend and indemnify every other Contributor
 * ("Indemnified Contributor") against any losses, damages and costs (collectively "Losses") arising from claims, lawsuits and other legal actions
 * brought by a third party against the Indemnified Contributor to the extent caused by the acts or omissions of such Commercial Contributor in
 * connection with its distribution of the Program in a commercial product offering. The obligations in this section do not apply to any claims or
 * Losses relating to any actual or alleged intellectual property infringement. In order to qualify, an Indemnified Contributor must: a) promptly
 * notify the Commercial Contributor in writing of such claim, and b) allow the Commercial Contributor to control, and cooperate with the
 * Commercial Contributor in, the defense and any related settlement negotiations. The Indemnified Contributor may participate in any such claim
 * at its own expense.
 * 
 * For example, a Contributor might include the Program in a commercial product offering, Product X. That Contributor is then a Commercial
 * Contributor. If that Commercial Contributor then makes performance claims, or offers warranties related to Product X, those performance claims
 * and warranties are such Commercial Contributor's responsibility alone. Under this section, the Commercial Contributor would have to defend
 * claims against the other Contributors related to those performance claims and warranties, and if a court requires any other Contributor to pay
 * any damages as a result, the Commercial Contributor must pay those damages.
 * 
 * 5. NO WARRANTY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, THE PROGRAM IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * EITHER EXPRESS OR IMPLIED INCLUDING, WITHOUT LIMITATION, ANY WARRANTIES OR CONDITIONS OF TITLE, NON-INFRINGEMENT, MERCHANTABILITY OR FITNESS
 * FOR A PARTICULAR PURPOSE. Each Recipient is solely responsible for determining the appropriateness of using and distributing the Program and
 * assumes all risks associated with its exercise of rights under this Agreement , including but not limited to the risks and costs of program
 * errors, compliance with applicable laws, damage to or loss of data, programs or equipment, and unavailability or interruption of operations.
 * 
 * 6. DISCLAIMER OF LIABILITY
 * 
 * EXCEPT AS EXPRESSLY SET FORTH IN THIS AGREEMENT, NEITHER RECIPIENT NOR ANY CONTRIBUTORS SHALL HAVE ANY LIABILITY FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING WITHOUT LIMITATION LOST PROFITS), HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OR DISTRIBUTION
 * OF THE PROGRAM OR THE EXERCISE OF ANY RIGHTS GRANTED HEREUNDER, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
 * 
 * 7. GENERAL
 * 
 * If any provision of this Agreement is invalid or unenforceable under applicable law, it shall not affect the validity or enforceability of the
 * remainder of the terms of this Agreement, and without further action by the parties hereto, such provision shall be reformed to the minimum
 * extent necessary to make such provision valid and enforceable.
 * 
 * If Recipient institutes patent litigation against any entity (including a cross-claim or counterclaim in a lawsuit) alleging that the Program
 * itself (excluding combinations of the Program with other software or hardware) infringes such Recipient's patent(s), then such Recipient's
 * rights granted under Section 2(b) shall terminate as of the date such litigation is filed.
 * 
 * All Recipient's rights under this Agreement shall terminate if it fails to comply with any of the material terms or conditions of this
 * Agreement and does not cure such failure in a reasonable period of time after becoming aware of such noncompliance. If all Recipient's rights
 * under this Agreement terminate, Recipient agrees to cease use and distribution of the Program as soon as reasonably practicable. However,
 * Recipient's obligations under this Agreement and any licenses granted by Recipient relating to the Program shall continue and survive.
 * 
 * Everyone is permitted to copy and distribute copies of this Agreement, but in order to avoid inconsistency the Agreement is copyrighted and may
 * only be modified in the following manner. The Agreement Steward reserves the right to publish new versions (including revisions) of this
 * Agreement from time to time. No one other than the Agreement Steward has the right to modify this Agreement. The Eclipse Foundation is the
 * initial Agreement Steward. The Eclipse Foundation may assign the responsibility to serve as the Agreement Steward to a suitable separate
 * entity. Each new version of the Agreement will be given a distinguishing version number. The Program (including Contributions) may always be
 * distributed subject to the version of the Agreement under which it was received. In addition, after a new version of the Agreement is
 * published, Contributor may elect to distribute the Program (including its Contributions) under the new version. Except as expressly stated in
 * Sections 2(a) and 2(b) above, Recipient receives no rights or licenses to the intellectual property of any Contributor under this Agreement,
 * whether expressly, by implication, estoppel or otherwise. All rights in the Program not expressly granted under this Agreement are reserved.
 * 
 * This Agreement is governed by the laws of the State of New York and the intellectual property laws of the United States of America. No party to
 * this Agreement will bring a legal action under this Agreement more than one year after the cause of action arose. Each party waives its rights
 * to a jury trial in any resulting litigation.
 */
package com.runescape.server.revised.actor.entity.character.update;

import java.io.IOException;
import java.io.OutputStream;

import com.runescape.server.revised.actor.entity.AbstractEntity;
import com.runescape.server.revised.actor.entity.EntityState;
import com.runescape.server.revised.actor.entity.character.player.login.game.GamePlayer;
import com.runescape.server.revised.actor.entity.character.update.blocks.appearance.Appearance;
import com.runescape.server.revised.actor.entity.character.update.blocks.chat.ChatMessage;
import com.runescape.server.revised.net.io.IOPacketBuffer;

public final class UpdateClass {

	private AbstractEntity<EntityState> entity;
	private UpdateMaskType updateMaskType;
	private IOPacketBuffer ioPacketBuffer;
	private IOPacketBuffer updateBlock;
	private OutputStream outputStream;
	private static IOPacketBuffer packet;

	public UpdateClass(final AbstractEntity<EntityState> entity, final IOPacketBuffer ioPacketBuffer, final OutputStream outputStream) {
		this.setEntity(entity);
		this.setIOPacketBuffer(ioPacketBuffer);
		this.setUpdateBlock(new IOPacketBuffer(new byte[1000]));
		this.setOutputStream(outputStream);
	}

	static {
		UpdateClass.setPacket(new IOPacketBuffer(new byte[100]));
	}

	protected void compute() {
		// add player and npc updating here
		// this.getIoPacketBuffer().initBitAccess();
		/** this.getUpdateBlock().setCurrentOffset(0);
		this.getIOPacketBuffer().createFrame(81);
		this.getIOPacketBuffer().initBitAccess();
		this.flushOutStream();
		this.updateThisPlayerMovement(this.getIOPacketBuffer());
		this.startUpdateBlock(this.getUpdateBlock(), (GamePlayer) this.getEntity());
		this.getIOPacketBuffer().writeBits(8, GameEngine.getGameEngine().getPlayerList().size());
		for (final Iterator<GamePlayer> playerIterator = GameEngine.getGameEngine().getPlayerList().iterator(); playerIterator.hasNext();) {
			final GamePlayer otherPlayer = playerIterator.next();
			if (GameEngine.getGameEngine().getPlayerList().contains(otherPlayer) && otherPlayer.getLocation().isWithinDistance(this.entity.getLocation())) {
				this.updatePlayerMovement(this.getIOPacketBuffer(), otherPlayer);
				this.startUpdateBlock(this.getUpdateBlock(), (GamePlayer) this.getEntity());
			} else {
				playerIterator.remove();
				this.getIOPacketBuffer().writeBits(1, 1);
				this.getIOPacketBuffer().writeBits(2, 3);
			}
		}
		for (final GamePlayer thisPlayer : GameEngine.getGameEngine().getPlayerList()) {
			if ((this.getEntity() == null) || (this.getEntity() == thisPlayer)) {
				continue;
			}
			if (GameEngine.getGameEngine().getPlayerList().contains(thisPlayer)) {
				continue;
			}
			this.addNewPlayer(this.getIOPacketBuffer(), thisPlayer);
		}
		if (this.getUpdateBlock().getCurrentOffset() > 0) {
			this.getIOPacketBuffer().writeBits(11, 2047);
			this.getIOPacketBuffer().finishBitAccess();
			this.getIOPacketBuffer().writeBytes(this.getUpdateBlock().getBuffer(), this.getUpdateBlock().getCurrentOffset(), 0);
		} else {
			this.getIOPacketBuffer().finishBitAccess();
		}
		this.getIOPacketBuffer().endFrameVarSizeWord();
		this.flushOutStream(); */
	}

	public void sendMapRegion() {
		this.getIOPacketBuffer().createFrame(73);
		this.getIOPacketBuffer().writeWordA(this.getEntity().getLocation().getRegionX() + 6);
		this.getIOPacketBuffer().writeWord(this.getEntity().getLocation().getRegionY() + 6);
		this.flushOutStream();
	}

	public void flushOutStream() {
		if (this.getIOPacketBuffer().getCurrentOffset() == 0) {
			return;
		}
		if (this.getIOPacketBuffer() == null) {
			System.out.println("Outstream is null.");
			return;
		}
		try {
			this.getOutputStream().write(this.getIOPacketBuffer().getBuffer(), 0, this.getIOPacketBuffer().getCurrentOffset());
		} catch (final IOException ioe) {
			ioe.printStackTrace();
		}
		this.getIOPacketBuffer().setCurrentOffset(0);
	}

	@SuppressWarnings("static-access")
	public void updateThisPlayerMovement(final IOPacketBuffer iOPacketBuffer) {
		// if (this.getEntity().isMapRegionChanging()) {
		this.sendMapRegion();
		// }
		if (this.getEntity().isTeleporting()) {
			iOPacketBuffer.writeBits(1, 1); // update required
			iOPacketBuffer.writeBits(2, 3); // player teleported
			iOPacketBuffer.writeBits(2, this.getEntity().getLocation().getZ()); // new player height

			// discard walking queue
			iOPacketBuffer.writeBits(1, this.getEntity().isTeleporting() ? 1 : 0);
			iOPacketBuffer.writeBits(1, this.getEntity().isUpdating() ? 1 : 0);
			// positions
			iOPacketBuffer.writeBits(7, this.getEntity().getLocation().getLocalY());
			iOPacketBuffer.writeBits(7, this.getEntity().getLocation().getLocalX());
		} else {
			this.getEntity().getMovementType();
			if (this.getEntity().getMovementType().WALKING.getID() == -1) { // check if player moved
				if (this.getEntity().isUpdating()) {
					iOPacketBuffer.writeBits(1, 1); // update is required
					iOPacketBuffer.writeBits(2, 0); // didn't move
				} else {
					iOPacketBuffer.writeBits(1, 0); // nothing changed
				}
			} else {
				if (this.getEntity().getMovementType().RUNNING.getID() == -1) { // check if player is running
					iOPacketBuffer.writeBits(1, 1); // update required
					iOPacketBuffer.writeBits(2, 1); // player only walked
					iOPacketBuffer.writeBits(3, this.getEntity().getMovementType().WALKING.getID()); // walking direction
					iOPacketBuffer.writeBits(1, this.getEntity().isUpdating() ? 1 : 0);
				} else {
					iOPacketBuffer.writeBits(1, 1); // update required
					iOPacketBuffer.writeBits(2, 2); // player ran
					iOPacketBuffer.writeBits(3, this.getEntity().getMovementType().WALKING.getID()); // walking
					iOPacketBuffer.writeBits(3, this.getEntity().getMovementType().RUNNING.getID()); // running
					iOPacketBuffer.writeBits(1, this.getEntity().isUpdating() ? 1 : 0);
				}
			}
		}
	}

	public void startUpdateBlock(final IOPacketBuffer iOPacketBuffer, final GamePlayer otherPlayer) {
		if (!otherPlayer.isUpdating()) {
			return;		// nothing required
		}



		/** UpdateMaskType[] updateMaskTypes = {
				UpdateMaskType.GRAPHIC, UpdateMaskType.ANIMATION, UpdateMaskType.FORCED_CHAT, UpdateMaskType.CHAT,
				UpdateMaskType.APPEARANCE, UpdateMaskType.FACE_ENTITY, UpdateMaskType.FACE_LOCATION, UpdateMaskType.HIT,
				UpdateMaskType.HIT_TWO
		};
		byte maskValue = 0;
		final UpdateMask updateMask2 = otherPlayer.getUpdateMask();
		for (byte b = 0; b < updateMaskTypes.length; b++) {
			if (updateMask2.get(updateMaskTypes[b])) {
				maskValue |= updateMaskTypes[b].getMaskID();
			}
		} */



		int mask = 0;
		final UpdateMask updateMask = otherPlayer.getUpdateMask();
		if (updateMask.get(UpdateMaskType.GRAPHIC)) {
			mask |= 0x100;
		}
		if (updateMask.get(UpdateMaskType.ANIMATION)) {
			mask |= 8;
		}
		if (updateMask.get(UpdateMaskType.FORCED_CHAT)) {
			mask |= 4;
		}
		if (updateMask.get(UpdateMaskType.CHAT)) {
			mask |= 0x80;
		}
		if (updateMask.get(UpdateMaskType.APPEARANCE)) {
			mask |= 0x10;
		}
		if (updateMask.get(UpdateMaskType.FACE_ENTITY)) {
			mask |= 0x1;
		}
		if (updateMask.get(UpdateMaskType.FACE_LOCATION)) {
			mask |= 0x2;
		}
		if (updateMask.get(UpdateMaskType.HIT)) {
			mask |= 0x20;
		}
		if (updateMask.get(UpdateMaskType.HIT_TWO)) {
			mask |= 0x200;
		}
		if (mask >= 0x100) {
			mask |= 0x40;
			iOPacketBuffer.writeByte((byte) (mask & 0xFF));
			iOPacketBuffer.writeByte((byte) (mask >> 8));
		} else {
			iOPacketBuffer.writeByte((byte) mask);
		}
		// now writing the various update blocks itself - note that their order crucial
		if (updateMask.get(UpdateMaskType.GRAPHIC)) {
			this.startGraphic(iOPacketBuffer, otherPlayer);
		}
		if (updateMask.get(UpdateMaskType.ANIMATION)) {
			this.startAnimation(iOPacketBuffer, otherPlayer);
		}
		if (updateMask.get(UpdateMaskType.FORCED_CHAT)) {
			// this.startForcedChat(ioPacketBuffer, otherPlayer);
		}
		if (updateMask.get(UpdateMaskType.CHAT)) {
			this.startChat(iOPacketBuffer, otherPlayer);
		}
		if (updateMask.get(UpdateMaskType.FACE_ENTITY)) {
			// this.appendFaceUpdate(str);
		}
		if (updateMask.get(UpdateMaskType.APPEARANCE)) {
			this.startAppearance(iOPacketBuffer, otherPlayer);
		}
		if (updateMask.get(UpdateMaskType.FACE_LOCATION)) {
			// this.appendSetFocusDestination(str);
		}
		if (updateMask.get(UpdateMaskType.HIT)) {
			// this.appendHitUpdate(str);
		}
		if (updateMask.get(UpdateMaskType.HIT_TWO)) {
			// this.appendHitUpdate2(str);
		}
	}

	@SuppressWarnings("static-access")
	public void updatePlayerMovement(final IOPacketBuffer packet, final GamePlayer otherPlayer) {
		if (otherPlayer.getMovementType().WALKING.getID() == -1) {
			if (otherPlayer.isUpdating()) {
				packet.writeBits(1, 1);
				packet.writeBits(2, 0); // no movement
			} else {
				packet.writeBits(1, 0);
			}
		} else if (otherPlayer.getMovementType().RUNNING.getID() == -1) {
			packet.writeBits(1, 1);
			packet.writeBits(2, 1); // moved one tile
			packet.writeBits(3, otherPlayer.getMovementType().WALKING.getID()); // walk direction
			packet.writeBits(1, otherPlayer.isUpdating() ? 1 : 0);
		} else {
			packet.writeBits(1, 1);
			packet.writeBits(2, 2); // moved two tiles
			packet.writeBits(3, otherPlayer.getMovementType().WALKING.getID()); // walk direction
			packet.writeBits(3, otherPlayer.getMovementType().RUNNING.getID()); // run direction
			packet.writeBits(1, otherPlayer.isUpdating() ? 1 : 0);
		}
	}

	public void addNewPlayer(final IOPacketBuffer packet, final GamePlayer otherPlayer) {
		packet.writeBits(11, otherPlayer.getID());
		packet.writeBits(1, 1); // update is required
		packet.writeBits(1, 1); // discard client-side walki queues
		final int yPos = otherPlayer.getLocation().getY() - this.getEntity().getLocation().getY();
		final int xPos = otherPlayer.getLocation().getX() - this.getEntity().getLocation().getX();
		packet.writeBits(5, yPos);
		packet.writeBits(5, xPos);
	}

	/** private static void appendHit2Update(final Player p, final PacketBuilder updateBlock) {
    	updateBlock.put((byte) p.getDamage().getHitDamage2());
    	updateBlock.putByteS((byte) p.getDamage().getHitType2());
    	updateBlock.put((byte) p.getSkills().getLevel(3));
    	updateBlock.putByteC(p.getSkills().getLevelForExperience(3));
    }

	private static void appendHitUpdate(final Player p, final PacketBuilder updateBlock) {
    	updateBlock.put((byte) p.getDamage().getHitDamage1());
    	updateBlock.putByteA(p.getDamage().getHitType1());
    	updateBlock.putByteC(p.getSkills().getLevel(3));
    	updateBlock.put((byte) p.getSkills().getLevelForExperience(3));
    } */

	public void startAnimation(final IOPacketBuffer block, final GamePlayer otherPlayer) {
		block.writeWordBigEndian(otherPlayer.getAnimation().getID());
		block.writeByteC(otherPlayer.getAnimation().getDelay());
	}

	public void startGraphic(final IOPacketBuffer block, final GamePlayer otherPlayer) {
		block.writeWordBigEndian(otherPlayer.getGraphic().getID());
		block.writeDWord(otherPlayer.getGraphic().getDelay());
	}

	private void startChat(final IOPacketBuffer packet, final GamePlayer otherPlayer) {
		final ChatMessage chatMessage = otherPlayer.getChatMessage();
		final String chat = chatMessage.getText();
		final byte[] bytes = chat.getBytes();
		packet.writeWordBigEndian(((chatMessage.getColor() & 0xFF) << 8) | (chatMessage.getEffects() & 0xFF));
		packet.writeByte(otherPlayer.getRank().getID());
		packet.writeByteC(bytes.length);
		for (int ptr = bytes.length -1; ptr >= 0; ptr--) {
			packet.writeByte(bytes[ptr]);
		}
	}

	private void startAppearance(final IOPacketBuffer packet, final GamePlayer otherPlayer) {
		final Appearance appearance = otherPlayer.getAppearance();
		UpdateClass.getPacket().writeByte(appearance.getGender().getID()); // gender
		UpdateClass.getPacket().writeByte((byte) 0); // skull icon
		for (int i = 0; i < 4; i++) {
			UpdateClass.getPacket().writeByte((byte) 0);
		}
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getChest()); // chest
		UpdateClass.getPacket().writeByte((byte) 0);
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getArms());
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getLegs());
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getHead());
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getHands());
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getFeet());
		UpdateClass.getPacket().writeWord((short) 0x100 + appearance.getBeard());
		UpdateClass.getPacket().writeByte((byte) appearance.getHairColor()); // hairc
		UpdateClass.getPacket().writeByte((byte) appearance.getTorsoColor()); // torsoc
		UpdateClass.getPacket().writeByte((byte) appearance.getLegColor()); // legc
		UpdateClass.getPacket().writeByte((byte) appearance.getFeetColor()); // feetc
		UpdateClass.getPacket().writeByte((byte) appearance.getSkinColor()); // skinc

		UpdateClass.getPacket().writeWord((short) 0x328); // stand
		UpdateClass.getPacket().writeWord((short) 0x337); // stand turn
		UpdateClass.getPacket().writeWord((short) 0x333); // walk
		UpdateClass.getPacket().writeWord((short) 0x334); // turn 180
		UpdateClass.getPacket().writeWord((short) 0x335); // turn 90 cw
		UpdateClass.getPacket().writeWord((short) 0x336); // turn 90 ccw
		UpdateClass.getPacket().writeWord((short) 0x338); // run

		UpdateClass.getPacket().writeQWord(UpdateClass.nameToLong(otherPlayer.getName())); // player name
		UpdateClass.getPacket().writeByte((byte) 0); // combat level
		UpdateClass.getPacket().writeWord(0); // (skill-level instead of combat-level) otherPlayer.getSkills().getTotalLevel()); // total level
		packet.writeByteC(UpdateClass.getPacket().getCurrentOffset());
		packet.writeBytes(UpdateClass.getPacket().getBuffer(), UpdateClass.getPacket().getCurrentOffset(), 0);
	}

	public static long nameToLong(final String s) {
		long l = 0L;
		for (int i = 0; (i < s.length()) && (i < 12); i++) {
			final char c = s.charAt(i);
			l *= 37L;
			if ((c >= 'A') && (c <= 'Z')) {
				l += (1 + c) - 65;
			} else if ((c >= 'a') && (c <= 'z')) {
				l += (1 + c) - 97;
			} else if ((c >= '0') && (c <= '9')) {
				l += (27 + c) - 48;
			}
		}
		while (((l % 37L) == 0L) && (l != 0L)) {
			l /= 37L;
		}
		return l;
	}

	public void setIOPacketBuffer(final IOPacketBuffer ioPacketBuffer) {
		this.ioPacketBuffer = ioPacketBuffer;
	}

	public IOPacketBuffer getIOPacketBuffer() {
		return this.ioPacketBuffer;
	}

	public void setEntity(final AbstractEntity<EntityState> entity) {
		this.entity = entity;
	}

	public AbstractEntity<EntityState> getEntity() {
		return this.entity;
	}

	public void setUpdateMaskType(final UpdateMaskType updateMaskType) {
		this.updateMaskType = updateMaskType;
	}

	public UpdateMaskType getUpdateMaskType() {
		return this.updateMaskType;
	}

	public void setUpdateBlock(final IOPacketBuffer updateBlock) {
		this.updateBlock = updateBlock;
	}

	public IOPacketBuffer getUpdateBlock() {
		return this.updateBlock;
	}

	public void setOutputStream(final OutputStream outputStream) {
		this.outputStream = outputStream;
	}

	public OutputStream getOutputStream() {
		return this.outputStream;
	}

	public static void setPacket(final IOPacketBuffer packet) {
		UpdateClass.packet = packet;
	}

	public static IOPacketBuffer getPacket() {
		return UpdateClass.packet;
	}
}
